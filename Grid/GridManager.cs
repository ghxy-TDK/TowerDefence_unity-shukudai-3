using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 格子系统管理器 - 核心单例类
/// 负责生成网格、管理路径数据以及格子的状态交互
/// </summary>
public class GridManager : MonoBehaviour
{
    // 单例实例
    public static GridManager Instance;

    #region 公共设置 (Public Settings)
    // 注意：为了保持与 GridEditor.cs 的兼容性，Public 变量保留驼峰命名法

    [Header("格子尺寸设置")]
    [Tooltip("网格宽度的格子数量")]
    public int gridWidth = 12;
    [Tooltip("网格高度的格子数量")]
    public int gridHeight = 8;
    [Tooltip("单个格子的物理尺寸")]
    public float cellSize = 1f;

    [Header("可视化设置")]
    public bool showGrid = true;
    public bool showDebugInfo = false;

    [Header("格子颜色配置")]
    public Color emptyColor = new Color(0.3f, 0.3f, 0.3f, 1f);      // 空地颜色
    public Color deployableColor = new Color(0.5f, 1f, 0.5f, 1f);   // 可部署区域颜色
    public Color pathColor = new Color(1f, 0.6f, 0.2f, 1f);         // 敌人路径颜色
    public Color startColor = Color.green;                          // 起点颜色
    public Color endColor = Color.red;                              // 终点颜色
    public Color highlightColor = Color.yellow;                     // 鼠标悬停高亮颜色

    [Header("路径设置")]
    [Tooltip("存储路径点的坐标列表")]
    public List<Vector2Int> pathPoints = new List<Vector2Int>();

    [Header("自动生成设置")]
    public bool autoGenerateDeployable = false;  // 是否在初始化时自动将路径周围设为可部署区域

    [Header("格子类型数据（由编辑器序列化保存）")]
    [SerializeField]
    private List<CellTypeData> savedCellTypes = new List<CellTypeData>();
    #endregion

    #region 私有变量 (Private Variables)
    // 核心网格数据：二维数组存储所有格子对象
    private GridCell[,] _grid;
    // 网格物体的父节点，用于保持Hierarchy整洁
    private GameObject _grid_parent;
    // 当前被高亮的格子引用
    private GridCell _highlighted_cell;
    #endregion

    /// <summary>
    /// 格子类型数据结构，用于序列化保存
    /// </summary>
    [System.Serializable]
    public class CellTypeData
    {
        public int x;
        public int y;
        public CellType cellType;

        public CellTypeData(int x, int y, CellType type)
        {
            this.x = x;
            this.y = y;
            this.cellType = type;
        }
    }

    void Awake()
    {
        // 实现单例模式，确保场景中只有一个 GridManager
        if (Instance == null)
        {
            GenerateGrid();         // 生成物理网格
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
            return;
        }
    }

    void Start()
    {
        
        ApplySavedCellTypes();  // 应用编辑器中保存的配置（如起点、终点）
        SetupPath();            // 初始化路径逻辑

        if (showDebugInfo)
        {
            Debug.Log($"[GridManager] 初始化完成: {gridWidth}x{gridHeight} = {gridWidth * gridHeight} 个格子");
            Debug.Log($"[GridManager] 已加载 {savedCellTypes.Count} 个自定义格子配置");
        }
    }

    /// <summary>
    /// 生成基础的格子网格系统
    /// </summary>
    void GenerateGrid()
    {
        // 创建由于容纳所有格子的父物体
        _grid_parent = new GameObject("Grid_Container");
        _grid_parent.transform.SetParent(transform);

        // 初始化二维数组
        _grid = new GridCell[gridWidth, gridHeight];

        // 遍历生成每个格子
        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                // 计算每个格子的世界坐标
                // 偏移量计算是为了让网格中心对齐到 (0,0)
                Vector3 _world_pos = new Vector3(
                    x * cellSize - (gridWidth * cellSize) / 2f + cellSize / 2f,
                    0.05f,  // Y轴稍微抬高，避免与地面产生 Z-fighting 闪烁
                    y * cellSize - (gridHeight * cellSize) / 2f + cellSize / 2f
                );

                // 实例化格子数据对象
                _grid[x, y] = new GridCell(x, y, _world_pos);

                // 如果开启可视化，则创建 3D Cube 显示
                if (showGrid)
                {
                    CreateCellVisual(_grid[x, y]);
                }
            }
        }
    }

    /// <summary>
    /// 创建单个格子的可视化 GameObject
    /// </summary>
    /// <param name="cell">目标格子数据</param>
    void CreateCellVisual(GridCell cell)
    {
        // 创建基础 Cube
        GameObject _cell_obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
        _cell_obj.name = $"Cell_{cell.x}_{cell.y}";
        _cell_obj.transform.SetParent(_grid_parent.transform);
        _cell_obj.transform.position = cell.worldPosition;
        // 稍微缩小一点尺寸，使格子之间有缝隙，视觉效果更好
        _cell_obj.transform.localScale = new Vector3(cellSize * 0.9f, 0.1f, cellSize * 0.9f);

        // 设置 Layer 为 Default，用于 GridInputHandler 的射线检测
        _cell_obj.layer = LayerMask.NameToLayer("Default");

        // 创建并赋值材质（使用轻量级的 Unlit Shader）
        Renderer _renderer = _cell_obj.GetComponent<Renderer>();
        Material _mat = new Material(Shader.Find("Unlit/Color"));
        _mat.color = emptyColor;
        _renderer.material = _mat;

        // 关闭阴影以优化性能
        _renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
        _renderer.receiveShadows = false;

        // 将 GameObject 引用保存回数据类
        cell.cellObject = _cell_obj;
    }

    /// <summary>
    /// 应用从编辑器保存的格子类型数据
    /// </summary>
    void ApplySavedCellTypes()
    {
        if (savedCellTypes.Count == 0) return;

        foreach (var data in savedCellTypes)
        {
            if (IsValidCell(data.x, data.y))
            {
                _grid[data.x, data.y].cellType = data.cellType;
                UpdateCellColor(_grid[data.x, data.y]);
            }
        }
    }

    /// <summary>
    /// 设置路径系统逻辑
    /// </summary>
    void SetupPath()
    {
        /// <summary>
        /// 设置路径系统
        /// </summary>
        void SetupPath()
        {
            // 修复逻辑：如果路径点列表为空，优先尝试从已加载的格子数据中重建
            if (pathPoints.Count == 0)
            {
                if (HasValidPathData())
                {
                    Debug.Log("检测到已保存的地图数据，正在从格子重建路径...");
                    ReconstructPathFromGrid();
                }
                else
                {
                    Debug.Log("未检测到路径数据，生成默认水平路径。");
                    CreateDefaultPath();
                }
            }

            // 设置路径格子的类型和颜色（确保列表和格子状态同步）
            for (int i = 0; i < pathPoints.Count; i++)
            {
                Vector2Int _point = pathPoints[i];

                if (IsValidCell(_point.x, _point.y))
                {
                    GridCell _cell = _grid[_point.x, _point.y];

                    // 设置类型
                    if (i == 0)
                        _cell.cellType = CellType.Start;
                    else if (i == pathPoints.Count - 1)
                        _cell.cellType = CellType.End;
                    else
                        _cell.cellType = CellType.Path;

                    // 更新颜色
                    UpdateCellColor(_cell);
                }
            }
        }
    }

    /// <summary>
    /// 检查当前网格中是否有有效的起点和终点
    /// </summary>
    bool HasValidPathData()
    {
        bool _has_start = false;
        bool _has_end = false;

        // 遍历所有格子检查类型
        foreach (var cell in _grid)
        {
            if (cell.cellType == CellType.Start) _has_start = true;
            if (cell.cellType == CellType.End) _has_end = true;
        }
        return _has_start && _has_end;
    }

    /// <summary>
    /// 【核心算法更新】使用 BFS (广度优先搜索) 重建最短路径
    /// </summary>
    void ReconstructPathFromGrid()
    {
        pathPoints.Clear();

        GridCell _start_cell = GetStartCell();
        GridCell _end_cell = GetEndCell();

        if (_start_cell == null || _end_cell == null)
        {
            Debug.LogError("无法构建路径：缺少起点或终点！");
            return;
        }

        // --- BFS 初始化 ---
        Queue<GridCell> _frontier = new Queue<GridCell>();
        Dictionary<GridCell, GridCell> _came_from = new Dictionary<GridCell, GridCell>();

        _frontier.Enqueue(_start_cell);
        _came_from[_start_cell] = null; // 起点的来源为空

        bool _found_end = false;

        // --- BFS 主循环 ---
        while (_frontier.Count > 0)
        {
            GridCell _current = _frontier.Dequeue();

            // 如果找到了终点，停止搜索
            if (_current == _end_cell)
            {
                _found_end = true;
                break;
            }

            // 遍历邻居
            foreach (GridCell _next in GetNeighbors(_current))
            {
                // 如果邻居是有效的路径类型 且 未被访问过
                if (IsPathable(_next) && !_came_from.ContainsKey(_next))
                {
                    _frontier.Enqueue(_next);
                    _came_from[_next] = _current; // 记录路径来源，用于回溯
                }
            }
        }

        // --- 路径回溯 (从终点反推回起点) ---
        if (_found_end)
        {
            GridCell _current = _end_cell;
            while (_current != null)
            {
                pathPoints.Add(new Vector2Int(_current.x, _current.y));
                _current = _came_from[_current];
            }

            // 因为是从终点回溯的，所以需要反转列表
            pathPoints.Reverse();

            Debug.Log($"✅ BFS 路径构建成功，长度: {pathPoints.Count}");
        }
        else
        {
            Debug.LogError("❌ 路径中断！无法从起点到达终点，请检查地图连通性。");
        }
    }

    /// <summary>
    /// 获取四个方向的邻居
    /// </summary>
    List<GridCell> GetNeighbors(GridCell cell)
    {
        List<GridCell> _results = new List<GridCell>();
        int[] _dx = { 0, 0, -1, 1 };
        int[] _dy = { 1, -1, 0, 0 };

        for (int i = 0; i < 4; i++)
        {
            int _nx = cell.x + _dx[i];
            int _ny = cell.y + _dy[i];

            if (IsValidCell(_nx, _ny))
            {
                _results.Add(_grid[_nx, _ny]);
            }
        }
        return _results;
    }

    /// <summary>
    /// 判断格子是否可以通行 (Path, Start, End 均可通行)
    /// </summary>
    bool IsPathable(GridCell cell)
    {
        return cell.cellType == CellType.Path ||
               cell.cellType == CellType.Start ||
               cell.cellType == CellType.End;
    }

    /// <summary>
    /// 创建默认的水平直线路径
    /// </summary>
    void CreateDefaultPath()
    {
        int _mid_y = gridHeight / 2;
        for (int x = 0; x < gridWidth; x++)
        {
            pathPoints.Add(new Vector2Int(x, _mid_y));
        }
    }

    /// <summary>
    /// 自动将路径周围的格子设置为可部署区域（高台）
    /// </summary>
    //void SetDeployableArea()
    //{
    //    for (int x = 0; x < gridWidth; x++)
    //    {
    //        for (int y = 0; y < gridHeight; y++)
    //        {
    //            GridCell _cell = _grid[x, y];

    //            // 规则：如果是空地 且 上下左右相邻格子中有路径，则视为可部署
    //            if (_cell.cellType == CellType.Empty && IsNearPath(x, y))
    //            {
    //                _cell.cellType = CellType.Deployable;
    //                UpdateCellColor(_cell);
    //            }
    //        }
    //    }
    //}

    /// <summary>
    /// 检查指定坐标是否相邻路径
    /// </summary>
    bool IsNearPath(int x, int y)
    {
        // 定义四个方向：左、右、上、下
        int[] _dx = { -1, 1, 0, 0 };
        int[] _dy = { 0, 0, -1, 1 };

        for (int i = 0; i < 4; i++)
        {
            int _new_x = x + _dx[i];
            int _new_y = y + _dy[i];

            if (IsValidCell(_new_x, _new_y))
            {
                CellType _type = _grid[_new_x, _new_y].cellType;
                if (_type == CellType.Path || _type == CellType.Start || _type == CellType.End)
                {
                    return true;
                }
            }
        }

        return false;
    }

    /// <summary>
    /// 根据格子类型更新其显示颜色
    /// </summary>
    void UpdateCellColor(GridCell cell)
    {
        if (cell.cellObject == null) return;

        Renderer _renderer = cell.cellObject.GetComponent<Renderer>();
        if (_renderer == null) return;

        Color _target_color;
        switch (cell.cellType)
        {
            case CellType.Deployable:
                _target_color = deployableColor;
                break;
            case CellType.Path:
                _target_color = pathColor;
                break;
            case CellType.Start:
                _target_color = startColor;
                break;
            case CellType.End:
                _target_color = endColor;
                break;
            default:
                _target_color = emptyColor;
                break;
        }

        _renderer.material.color = _target_color;
    }

    #region 公共 API (Public Methods)

    /// <summary>
    /// 保存当前格子类型配置到列表（供 GridEditor 调用）
    /// </summary>
    public void SaveCellTypes()
    {
        savedCellTypes.Clear();

        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                if (_grid != null && _grid[x, y] != null)
                {
                    CellType _type = _grid[x, y].cellType;
                    // 只保存非空地类型的格子，减少数据量
                    if (_type != CellType.Empty)
                    {
                        savedCellTypes.Add(new CellTypeData(x, y, _type));
                    }
                }
            }
        }

        Debug.Log($"✅ [GridManager] 保存了 {savedCellTypes.Count} 个格子类型数据");
    }

    /// <summary>
    /// 设置指定坐标的格子类型
    /// </summary>
    public void SetCellType(int x, int y, CellType type)
    {
        if (_grid != null && IsValidCell(x, y))
        {
            _grid[x, y].cellType = type;
        }
    }

    /// <summary>
    /// 获取指定坐标的格子类型
    /// </summary>
    public CellType GetCellType(int x, int y)
    {
        if (_grid != null && IsValidCell(x, y))
        {
            return _grid[x, y].cellType;
        }
        return CellType.Empty;
    }

    /// <summary>
    /// 高亮指定格子（鼠标悬停时调用）
    /// </summary>
    public void HighlightCell(GridCell cell)
    {
        // 1. 恢复上一个高亮格子的颜色
        if (_highlighted_cell != null && _highlighted_cell.cellObject != null)
        {
            UpdateCellColor(_highlighted_cell);
        }

        // 2. 设置新格子为高亮色
        if (cell != null && cell.cellObject != null)
        {
            Renderer _renderer = cell.cellObject.GetComponent<Renderer>();
            if (_renderer != null)
            {
                _renderer.material.color = highlightColor;
            }
            _highlighted_cell = cell;
        }
    }

    /// <summary>
    /// 清除当前的高亮状态
    /// </summary>
    public void ClearHighlight()
    {
        if (_highlighted_cell != null)
        {
            UpdateCellColor(_highlighted_cell);
            _highlighted_cell = null;
        }
    }

    /// <summary>
    /// 将世界坐标转换为对应的格子对象
    /// </summary>
    public GridCell GetCellFromWorld(Vector3 worldPos)
    {
        // 逆向计算：从世界坐标推导网格索引
        int x = Mathf.RoundToInt((worldPos.x + (gridWidth * cellSize) / 2f) / cellSize - 0.5f);
        int y = Mathf.RoundToInt((worldPos.z + (gridHeight * cellSize) / 2f) / cellSize - 0.5f);

        return GetCell(x, y);
    }

    /// <summary>
    /// 根据索引获取格子对象（带边界检查）
    /// </summary>
    public GridCell GetCell(int x, int y)
    {
        if (IsValidCell(x, y))
        {
            return _grid[x, y];
        }
        return null;
    }

    /// <summary>
    /// 验证坐标是否在网格范围内
    /// </summary>
    public bool IsValidCell(int x, int y)
    {
        return x >= 0 && x < gridWidth && y >= 0 && y < gridHeight;
    }

    /// <summary>
    /// 获取路径上的下一个格子（用于敌人移动导航）
    /// </summary>
    public GridCell GetNextPathCell(GridCell currentCell)
    {
        // 遍历路径点列表查找当前位置
        for (int i = 0; i < pathPoints.Count - 1; i++)
        {
            if (pathPoints[i].x == currentCell.x && pathPoints[i].y == currentCell.y)
            {
                Vector2Int _next_point = pathPoints[i + 1];
                return _grid[_next_point.x, _next_point.y];
            }
        }

        return null;  // 已到达终点或不在路径上
    }

    /// <summary>
    /// 获取路径起点终点格子
    /// </summary>
    public new GridCell GetStartCell()
    {
        foreach (var cell in _grid) if (cell.cellType == CellType.Start) return cell;
        return null;
    }

    public new GridCell GetEndCell()
    {
        foreach (var cell in _grid) if (cell.cellType == CellType.End) return cell;
        return null;
    }

    #endregion

    /// <summary>
    /// 编辑器辅助显示：在 Scene 视图中绘制网格线和路径箭头
    /// </summary>
    void OnDrawGizmos()
    {
        if (!showGrid || _grid == null) return;

        // 1. 绘制网格线
        Gizmos.color = new Color(1f, 1f, 1f, 0.3f);

        // 绘制垂直线
        for (int x = 0; x <= gridWidth; x++)
        {
            Vector3 _start = new Vector3(
                x * cellSize - (gridWidth * cellSize) / 2f,
                0,
                -(gridHeight * cellSize) / 2f
            );
            Vector3 _end = new Vector3(
                x * cellSize - (gridWidth * cellSize) / 2f,
                0,
                (gridHeight * cellSize) / 2f
            );
            Gizmos.DrawLine(_start, _end);
        }

        // 绘制水平线
        for (int y = 0; y <= gridHeight; y++)
        {
            Vector3 _start = new Vector3(
                -(gridWidth * cellSize) / 2f,
                0,
                y * cellSize - (gridHeight * cellSize) / 2f
            );
            Vector3 _end = new Vector3(
                (gridWidth * cellSize) / 2f,
                0,
                y * cellSize - (gridHeight * cellSize) / 2f
            );
            Gizmos.DrawLine(_start, _end);
        }

        // 2. 绘制路径方向箭头
        if (pathPoints.Count > 1)
        {
            Gizmos.color = Color.yellow;
            for (int i = 0; i < pathPoints.Count - 1; i++)
            {
                Vector2Int _current = pathPoints[i];
                Vector2Int _next = pathPoints[i + 1];

                if (IsValidCell(_current.x, _current.y) && IsValidCell(_next.x, _next.y))
                {
                    // 获取两点的世界坐标
                    Vector3 _from = _grid[_current.x, _current.y].worldPosition;
                    Vector3 _to = _grid[_next.x, _next.y].worldPosition;

                    // 稍微抬高显示
                    _from.y = 0.2f;
                    _to.y = 0.2f;

                    Gizmos.DrawLine(_from, _to);

                    // 绘制箭头头部
                    Vector3 _direction = (_to - _from).normalized;
                    Vector3 _arrow_point = _to - _direction * 0.2f;
                    Vector3 _right = Vector3.Cross(_direction, Vector3.up) * 0.15f;

                    Gizmos.DrawLine(_to, _arrow_point + _right);
                    Gizmos.DrawLine(_to, _arrow_point - _right);
                }
            }
        }
    }
}